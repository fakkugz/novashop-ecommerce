var N=Object.defineProperty;var w=Object.getOwnPropertySymbols;var E=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var C=(e,t,n)=>t in e?N(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,g=(e,t)=>{for(var n in t||(t={}))E.call(t,n)&&C(e,n,t[n]);if(w)for(var n of w(t))x.call(t,n)&&C(e,n,t[n]);return e};function I(e,t=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(t)}function O(e,t=`expected an object, instead received ${typeof e}`){if(typeof e!="object")throw new TypeError(t)}function $(e,t="expected all items to be functions, instead received the following types: "){if(!e.every(n=>typeof n=="function")){const n=e.map(s=>typeof s=="function"?`function ${s.name||"unnamed"}()`:typeof s).join(", ");throw new TypeError(`${t}[${n}]`)}}var j=e=>Array.isArray(e)?e:[e];function W(e){const t=Array.isArray(e[0])?e[0]:e;return $(t,"createSelector expects all input-selectors to be functions, but received the following types: "),t}function A(e,t){const n=[],{length:s}=e;for(let r=0;r<s;r++)n.push(e[r].apply(null,t));return n}var D=class{constructor(e){this.value=e}deref(){return this.value}},F=typeof WeakRef!="undefined"?WeakRef:D,q=0,M=1;function R(){return{s:q,v:void 0,o:null,p:null}}function S(e,t={}){let n=R();const{resultEqualityCheck:s}=t;let r,c=0;function i(){var m,v;let o=n;const{length:y}=arguments;for(let p=0,h=y;p<h;p++){const f=arguments[p];if(typeof f=="function"||typeof f=="object"&&f!==null){let a=o.o;a===null&&(o.o=a=new WeakMap);const d=a.get(f);d===void 0?(o=R(),a.set(f,o)):o=d}else{let a=o.p;a===null&&(o.p=a=new Map);const d=a.get(f);d===void 0?(o=R(),a.set(f,o)):o=d}}const l=o;let u;if(o.s===M)u=o.v;else if(u=e.apply(null,arguments),c++,s){const p=(v=(m=r==null?void 0:r.deref)==null?void 0:m.call(r))!=null?v:r;p!=null&&s(p,u)&&(u=p,c!==0&&c--),r=typeof u=="object"&&u!==null||typeof u=="function"?new F(u):u}return l.s=M,l.v=u,u}return i.clearCache=()=>{n=R(),i.resetResultsCount()},i.resultsCount=()=>c,i.resetResultsCount=()=>{c=0},i}function K(e,...t){const n=typeof e=="function"?{memoize:e,memoizeOptions:t}:e,s=(...r)=>{let c=0,i=0,o,y={},l=r.pop();typeof l=="object"&&(y=l,l=r.pop()),I(l,`createSelector expects an output function after the inputs, but received: [${typeof l}]`);const u=g(g({},n),y),{memoize:m,memoizeOptions:v=[],argsMemoize:p=S,argsMemoizeOptions:h=[]}=u,f=j(v),a=j(h),d=W(r),b=m(function(){return c++,l.apply(null,arguments)},...f),T=p(function(){i++;const z=A(d,arguments);return o=b.apply(null,z),o},...a);return Object.assign(T,{resultFunc:l,memoizedResultFunc:b,dependencies:d,dependencyRecomputations:()=>i,resetDependencyRecomputations:()=>{i=0},lastResult:()=>o,recomputations:()=>c,resetRecomputations:()=>{c=0},memoize:m,argsMemoize:p})};return Object.assign(s,{withTypes:()=>s}),s}var P=K(S),U=Object.assign((e,t=P)=>{O(e,`createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`);const n=Object.keys(e),s=n.map(c=>e[c]);return t(s,(...c)=>c.reduce((i,o,y)=>(i[n[y]]=o,i),{}))},{withTypes:()=>U});export{P as c};
